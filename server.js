// Servidor Node.js con Socket.IO, Firebase Firestore y Storage
// üí¨ Compatible con tu app Android (SocketRepository y RoomManager actuales)
// üé® Logs con colores y emojis para depuraci√≥n

const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const { v4: uuidv4 } = require('uuid');
const admin = require('firebase-admin');
const { Buffer } = require('buffer');

// üé® ANSI colors
const colors = {
  reset: '\x1b[0m',
  cyan: '\x1b[36m',
  yellow: '\x1b[33m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  magenta: '\x1b[35m',
  blue: '\x1b[34m',
};

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
  cors: { origin: '*', methods: ['GET', 'POST'] },
  path: '/socket.io/',
  transports: ['polling', 'websocket'], // aseguramos compatibilidad
  maxHttpBufferSize: 1e8,
});


app.use(cors());

// -------------------------------
// üî• Firebase init
// -------------------------------
if (!process.env.GOOGLE_APPLICATION_CREDENTIALS || !process.env.FIREBASE_STORAGE_BUCKET) {
  console.error(`${colors.red}‚ùå Falta configuraci√≥n de Firebase${colors.reset}`);
  process.exit(1);
}

try {
  const serviceAccount = JSON.parse(process.env.GOOGLE_APPLICATION_CREDENTIALS);
  admin.initializeApp({
    credential: admin.credential.cert(serviceAccount),
    storageBucket: process.env.FIREBASE_STORAGE_BUCKET,
  });
  console.log(`${colors.green}‚úÖ Firebase inicializado correctamente.${colors.reset}`);
} catch (err) {
  console.error(`${colors.red}‚ùå Error al inicializar Firebase:${colors.reset}`, err);
  process.exit(1);
}

const db = admin.firestore();
const bucket = admin.storage().bucket();

const USERS_COLLECTION = 'users';
const MESSAGES_COLLECTION = 'messages';

// -------------------------------
// üì¶ Estado en memoria
// -------------------------------
const connectedUsers = new Map();     // userId -> { id, username, email, socketId, ... }
const socketToUserMap = new Map();    // socket.id -> userId
const rooms = new Map();              // roomId -> { id, name, description, users:Set<userId>, currentSpeaker, type, isPrivate }
const userToRoomMap = new Map();      // userId -> roomId

// -------------------------------
// üö™ Salas base
// -------------------------------
const SALAS_ROOM_ID = 'salas';        // üÜï Lobby
const GENERAL_ROOM_ID = 'general';
const HANDY_ROOM_ID = 'handy';

rooms.set(SALAS_ROOM_ID, {
  id: SALAS_ROOM_ID,
  name: 'Lobby de Salas',
  description: 'Pantalla de selecci√≥n de salas',
  users: new Set(),
  currentSpeaker: null,
  type: 'lobby',
  isPrivate: false,
});

rooms.set(GENERAL_ROOM_ID, {
  id: GENERAL_ROOM_ID,
  name: 'Chat General',
  description: 'Sala de chat p√∫blico',
  users: new Set(),
  currentSpeaker: null,
  type: 'general',
  isPrivate: false,
});

rooms.set(HANDY_ROOM_ID, {
  id: HANDY_ROOM_ID,
  name: 'Radio Handy (PTT)',
  description: 'Simulaci√≥n de radio PTT',
  users: new Set(),
  currentSpeaker: null,
  type: 'ptt',
  isPrivate: false,
});

// -------------------------------
// üîß Helpers
// -------------------------------
function serializeRoom(room) {
  return {
    id: room.id,
    name: room.name,
    description: room.description || '',
    userCount: room.users?.size || 0,
    maxUsers: 50,
    type: room.type || (room.id === HANDY_ROOM_ID ? 'ptt' : 'general'),
    isPrivate: !!room.isPrivate,
    currentSpeakerId: room.currentSpeaker || null,
  };
}

function serializeRooms() {
  return Array.from(rooms.values()).map(serializeRoom);
}

function getRoomUsers(roomId) {
  const room = rooms.get(roomId);
  if (!room) return [];
  return Array.from(room.users)
    .map((id) => connectedUsers.get(id))
    .filter(Boolean);
}

// -------------------------------
app.get('/health', (_, res) => res.status(200).send('Servidor operativo.'));
app.get('/users', (_, res) => res.json(Array.from(connectedUsers.values())));
app.get('/rooms', (_, res) => res.json(serializeRooms()));
// -------------------------------

// üîå Conexi√≥n Socket.IO
io.on('connection', (socket) => {
  console.log(`${colors.cyan}‚úÖ Nuevo socket conectado: ${socket.id}${colors.reset}`);

  // üì• Registro de usuario
  socket.on('user-connected', async (user) => {
    console.log(`${colors.blue}üì• user-connected:${colors.reset}`, user);
    if (!user || !user.id || !user.username) {
      console.warn(`${colors.yellow}‚ö†Ô∏è Datos de usuario inv√°lidos.${colors.reset}`);
      return;
    }

    socketToUserMap.set(socket.id, user.id);
    connectedUsers.set(user.id, { ...user, socketId: socket.id, isOnline: true });

    try {
      await db.collection(USERS_COLLECTION).doc(user.id).set(user, { merge: true });
      console.log(`${colors.green}üíæ Usuario guardado en Firestore:${colors.reset} ${user.username}`);
    } catch (e) {
      console.error(`${colors.red}‚ùå Error guardando usuario:${colors.reset}`, e);
    }

    // Lista global de usuarios conectados
    io.emit('connected_users', Array.from(connectedUsers.values()));

    // Lista de salas serializada (para RoomManager)
    socket.emit('room_list', serializeRooms());

    // üìù NO auto-unimos a ninguna sala aqu√≠.
    // El cliente decidir√° y emitir√° join_room("salas") en SalasScreen.
  });

  // üß© Aux: salir de la sala actual
  const leaveCurrentRoom = (userId, socket) => {
    const prevRoomId = userToRoomMap.get(userId);
    if (prevRoomId && rooms.has(prevRoomId)) {
      const room = rooms.get(prevRoomId);
      room.users.delete(userId);
      socket.leave(prevRoomId);

      // Si era Handy y hablaba, soltar token
      if (prevRoomId === HANDY_ROOM_ID && room.currentSpeaker === userId) {
        room.currentSpeaker = null;
        io.to(HANDY_ROOM_ID).emit('talk_token_released', { roomId: HANDY_ROOM_ID, currentSpeaker: null });
      }

      io.to(prevRoomId).emit('user-left-room', { roomId: prevRoomId, userCount: room.users.size });
      console.log(`${colors.yellow}üëã ${userId} sali√≥ de ${prevRoomId}${colors.reset}`);
    }
  };

  // üè† Unirse a sala (idempotente y compatible con Android)
socket.on('join_room', (data = {}) => {
  const roomName = data.room || data.roomId;
  const { userId, username } = data;
  console.log(`${colors.cyan}üì• join_room:${colors.reset}`, data);

  // üîç Validaciones b√°sicas
  if (!roomName || !userId || !username) {
    socket.emit('join_error', { message: 'Datos de uni√≥n incompletos' });
    console.warn(`${colors.yellow}‚ö†Ô∏è join_room con datos incompletos${colors.reset}`);
    return;
  }

  if (!rooms.has(roomName)) {
    socket.emit('join_error', { message: `La sala ${roomName} no existe` });
    console.warn(`${colors.yellow}‚ö†Ô∏è Sala inexistente: ${roomName}${colors.reset}`);
    return;
  }

  const room = rooms.get(roomName);

  // üß≠ Si ya est√° en la misma sala, confirmar igual (evita timeout)
  const current = userToRoomMap.get(userId);
  if (current === roomName) {
    const users = getRoomUsers(roomName);
    socket.emit('join_success', {
      message: `Ya estabas en ${roomName}`,
      room: roomName,
      roomId: roomName,
      users,
      currentSpeaker: room.currentSpeaker,
      userCount: users.length,
    });
    socket.emit('room_joined', { roomId: roomName, username, userCount: users.length }); // üëà Compatibilidad Android
    console.log(`${colors.yellow}‚ÑπÔ∏è ${username} ya estaba en ${roomName}${colors.reset}`);
    return;
  }

  // üîÑ Salir de la sala anterior si corresponde
  leaveCurrentRoom(userId, socket);

  // üö™ Unirse a la nueva sala
  socket.join(roomName);
  room.users.add(userId);
  userToRoomMap.set(userId, roomName);

  const users = getRoomUsers(roomName);

  // ‚úÖ Confirmaciones al cliente Android
  socket.emit('join_success', {
    message: `Te has unido a ${roomName}`,
    room: roomName,
    roomId: roomName,
    users,
    currentSpeaker: room.currentSpeaker,
    userCount: users.length,
  });

  // üîπ Evento esperado por tu app (ChatViewModel)
  socket.emit('room_joined', { roomId: roomName, username, userCount: users.length });

  // üì¢ Broadcast a todos los usuarios de la sala
  io.to(roomName).emit('user-joined-room', { roomId: roomName, userCount: users.length });

  console.log(`${colors.green}‚úÖ ${username} se uni√≥ a ${roomName}${colors.reset}`);
});


    // Broadcast de actualizaci√≥n de contador
    io.to(roomName).emit('user-joined-room', { roomId: roomName, userCount: users.length });

    console.log(`${colors.green}‚úÖ ${username} se uni√≥ a ${roomName}${colors.reset}`);
  });

  // üö™ Salir de sala (desde cliente)
  // üè† Unirse a sala (idempotente y compatible con Android)
socket.on('join_room', (data = {}) => {
  const roomName = data.room || data.roomId;
  const { userId, username } = data;
  console.log(`${colors.cyan}üì• join_room:${colors.reset}`, data);

  // üîç Validaciones b√°sicas
  if (!roomName || !userId || !username) {
    socket.emit('join_error', { message: 'Datos de uni√≥n incompletos' });
    console.warn(`${colors.yellow}‚ö†Ô∏è join_room con datos incompletos${colors.reset}`);
    return;
  }
  if (!rooms.has(roomName)) {
    socket.emit('join_error', { message: `La sala ${roomName} no existe` });
    console.warn(`${colors.yellow}‚ö†Ô∏è Sala inexistente: ${roomName}${colors.reset}`);
    return;
  }

  const room = rooms.get(roomName);

  // üß≠ Si ya est√° en la misma sala, devolver confirmaci√≥n inmediata
  const current = userToRoomMap.get(userId);
  if (current === roomName) {
    const users = getRoomUsers(roomName);
    socket.emit('join_success', {
      message: `Ya estabas en ${roomName}`,
      room: roomName,
      roomId: roomName,
      users,
      currentSpeaker: room.currentSpeaker,
      userCount: users.length,
    });
    socket.emit("room_joined", { roomId: roomName, username, userCount: users.length }); // üîπ Compatibilidad Android
    console.log(`${colors.yellow}‚ÑπÔ∏è ${username} ya estaba en ${roomName}${colors.reset}`);
    return;
  }

  // üîÑ Salir de sala anterior si corresponde
  leaveCurrentRoom(userId, socket);

  // üö™ Unirse a la nueva sala
  socket.join(roomName);
  room.users.add(userId);
  userToRoomMap.set(userId, roomName);

  const users = getRoomUsers(roomName);

  // ‚úÖ Confirmaci√≥n al cliente
  socket.emit('join_success', {
    message: `Te has unido a ${roomName}`,
    room: roomName,
    roomId: roomName,
    users,
    currentSpeaker: room.currentSpeaker,
    userCount: users.length,
  });

  // üîπ Confirmaci√≥n r√°pida para Android
  socket.emit("room_joined", { roomId: roomName, username, userCount: users.length });

  // üì¢ Broadcast: notificar a la sala que alguien se uni√≥
  io.to(roomName).emit('user-joined-room', { roomId: roomName, userCount: users.length });

  console.log(`${colors.green}‚úÖ ${username} se uni√≥ a ${roomName}${colors.reset}`);
});


  // üë• Lista de usuarios por sala ‚Äî alias compatibles con Android
  socket.on('get_users', (data = {}) => {
    const roomId = data.roomId || data.room || SALAS_ROOM_ID;
    const users = getRoomUsers(roomId);
    console.log(`${colors.magenta}üë• Enviando usuarios de sala (get_users):${colors.reset} ${roomId}`);
    socket.emit('users_list', users);
  });
 


  // (Compatibilidad) nombre anterior
  socket.on('get_room_users', (roomName) => {
    const roomId = typeof roomName === 'string' ? roomName : roomName?.roomId || SALAS_ROOM_ID;
    const users = getRoomUsers(roomId);
    console.log(`${colors.magenta}üë• Enviando usuarios de sala (get_room_users):${colors.reset} ${roomId}`);
    socket.emit('users_list', users);
  });

  // üåç Lista global
  socket.on('get_all_users', () => {
    socket.emit('connected_users', Array.from(connectedUsers.values()));
  });

  // üéôÔ∏è PTT: solicitar token
  socket.on('request_talk_token', ({ userId, roomId }) => {
    const room = rooms.get(roomId);
    if (!room) return;

    if (!room.currentSpeaker) {
      room.currentSpeaker = userId;
      const username = connectedUsers.get(userId)?.username || 'Desconocido';
      io.to(roomId).emit('talk_token_granted', { roomId, currentSpeaker: userId, username });
      console.log(`${colors.green}üéôÔ∏è ${username} tom√≥ el token en ${roomId}${colors.reset}`);
    } else if (room.currentSpeaker !== userId) {
      socket.emit('talk_token_denied', { roomId, currentSpeaker: room.currentSpeaker });
      console.log(`${colors.yellow}üö´ Token denegado para ${userId}${colors.reset}`);
    }
  });

  // üîá PTT: liberar token
  socket.on('release_talk_token', ({ userId, roomId }) => {
    const room = rooms.get(roomId);
    if (room && room.currentSpeaker === userId) {
      room.currentSpeaker = null;
      io.to(roomId).emit('talk_token_released', { roomId, currentSpeaker: null });
      console.log(`${colors.cyan}üîá ${userId} liber√≥ el token en ${roomId}${colors.reset}`);
    }
  });

  // üí¨ Mensajes de texto
  socket.on('send_message', async (data = {}) => {
    const { userId, username, text, roomId } = data;
    if (!text || !userId || !roomId) return;

    const message = {
      id: uuidv4(),
      userId,
      username,
      text,
      roomId,
      timestamp: Date.now(),
    };

    try {
      await db.collection(MESSAGES_COLLECTION).add(message);
      io.to(roomId).emit('new_message', message);
      console.log(`${colors.green}üí¨ Mensaje de ${username} ‚Üí ${roomId}:${colors.reset} ${text}`);
    } catch (e) {
      console.error(`${colors.red}‚ùå Error guardando mensaje:${colors.reset}`, e);
    }
  });

  // üéß Mensajes de audio (espera audioData en base64)
  socket.on('audio_message', async (data = {}) => {
    const { userId, username, audioData, roomId } = data;
    if (!audioData || !userId || !roomId) {
      console.warn(`${colors.yellow}‚ö†Ô∏è audio_message inv√°lido (falta audioData/userId/roomId)${colors.reset}`);
      return;
    }

    const room = rooms.get(roomId);
    if (roomId === HANDY_ROOM_ID && room?.currentSpeaker !== userId) {
      socket.emit('audio_transmission_failed', { message: 'No tienes el token de palabra (PTT).' });
      console.log(`${colors.yellow}‚ö†Ô∏è Audio rechazado (sin token) para ${username}${colors.reset}`);
      return;
    }

    try {
      const buffer = Buffer.from(audioData, 'base64');
      const filePath = `audios/${roomId}/${userId}_${Date.now()}_${uuidv4()}.m4a`;
      const file = bucket.file(filePath);
      await file.save(buffer, { contentType: 'audio/m4a', resumable: false });
      await file.makePublic();
      const url = file.publicUrl();

      const audioMsg = {
        id: uuidv4(),
        userId,
        username,
        audioUrl: url,
        roomId,
        timestamp: Date.now(),
      };

      await db.collection(MESSAGES_COLLECTION).add(audioMsg);
      io.to(roomId).emit('new_message', audioMsg);
      console.log(`${colors.green}üé§ Audio subido por ${username} (${roomId})${colors.reset}`);
    } catch (err) {
      console.error(`${colors.red}‚ùå Error subiendo audio:${colors.reset}`, err);
    }
  });

  // üî¥ Desconexi√≥n
  socket.on('disconnect', () => {
    const userId = socketToUserMap.get(socket.id);
    if (userId) {
      leaveCurrentRoom(userId, socket);
      connectedUsers.delete(userId);
      userToRoomMap.delete(userId);
      io.emit('connected_users', Array.from(connectedUsers.values()));
    }
    socketToUserMap.delete(socket.id);
    console.log(`${colors.red}üî¥ Socket desconectado:${colors.reset} ${socket.id}`);
  });
});

// -------------------------------
// üöÄ Iniciar servidor
// -------------------------------
const PORT = process.env.PORT || 8080;
server.listen(PORT, () => {
  console.log(`${colors.green}üöÄ Servidor corriendo en puerto ${PORT}${colors.reset}`);
  console.log(`${colors.cyan}üåê http://localhost:${PORT}${colors.reset}`);
});
